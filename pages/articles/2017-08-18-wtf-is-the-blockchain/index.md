---
title: "WTF is The Blockchain? (한글 번역)"
date: "2017-08-18T22:12:03.284Z"
layout: post
path: "/wtf-is-blockchain-korean-translation/"
category: "Tech-Trend"
description: "블록 체인을 이해하기 위한 3500단어짜리 궁극의 가이드"
---

<br/>

해당 글은 HackerNoon에 기재된 글을 번역한 글입니다. (Special thanks to Mr. Mohit Momoria)

<strong>원본 링크: </strong>https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348
<strong>번역 미디엄 링크: </strong> https://medium.com/@tea1528/%ED%95%B4%EB%8B%B9-%EA%B8%80%EC%9D%80-hackernoon%EC%97%90-%EA%B8%B0%EC%9E%AC%EB%90%9C-%EA%B8%80%EC%9D%84-%EB%B2%88%EC%97%AD%ED%95%9C-%EA%B8%80%EC%9E%85%EB%8B%88%EB%8B%A4-special-thanks-to-mr-mohit-momoria-702986ebb4c6

<br/>

<figure class="floatCenter">
	<img style="height: 400px; " src="./coin.png" alt="coint">
	<figcaption>http://www.forexnewsnow.com/top-stories/bitcoin-2016-summary-2017-forecasts/</figcaption>
</figure>

당신이 바위 밑에서 숨어 지내고 있는 게 아니라면 아마 비트코인이나 블록체인에 대해서 들어봤을 것이다. 어쨌든, 최근 핫한 트렌드이자 미디아가 가장 좋아하는 올해의 유행어이기 때문이다. 전자화폐 (cryptocurrency)에 대해 관심이 없거나 이해하지 못하는 사람조차도 이에 대해 관심을 갖기 시작했다. 필자는 공대생 친구보다 문과 친구가 더 많다. 그들이 며칠 째 나에게 이 새로운 유행어를 설명해달라고 귀찮게 해왔다. 아마 필자와 비슷한 상황을 겪을 사람이 무수히 많을 것이라 생각된다. 이러한 계기를 통해 필자는 보통의 네티즌이 이해할 수 있는 수준의 언어로 블록체인을 설명하려 한다.

<br/>

>참고로, 필자는 미래의 아이디어를 당신의 우편함에 매주 전달하는 뉴스 레터 Unmade의 큐레이터이다.

## 블록 체인: 왜 우리는 이렇게 복잡한 게 필요한가?
<figure>
	<blockquote>
		<p>모든 복잡한 문제에는 명료하고 간단하고 부정확한 답이 있다. </p>
		<footer>
			<cite>-H.L.Mencken</cite>
		</footer>
	</blockquote>
</figure>

<strong>인터넷 상에 있는 다른 모든 글과는 다르게,</strong> 블록체인을 정의하기 전에 먼저 이것이 해결하고자 하는 문제에 대해 알아보자.
<br/>
<br/>
조(Joe)가 당신의 가장 친한 친구라고 가정해 보자. 그가 해외여행 중, 닷새째 되는 날, 그는 당신에게 전화해, “어이, 나 돈 좀 필요해. 수중에 돈을 다 썼어.”
<br/>
<br/>
당신이, “바로 보낼게” 하고 전화를 끊는다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./joe1.png" alt="joe1">
</figure>

당신은 당신의 은행의 계좌 매니저에게 전화해, “조의 계좌로 1000 달러를 이체해주세요.”라고 말한다.
<br/>
<br/>
은행원은 알겠다고 답한다.
<br/>
<br/>
그는 계좌를 열어 당신의 잔액이 조에게 1000 달러를 송금할 만큼 충분한 지 확인한다. 당신은 부자이기 때문에, 당신 계좌에는 잔액이 많다. 따라서 해당 은행원은 다음과 같이 통장에 기입한다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./joe2.png" alt="joe2">
	<figcaption>간단하게 하기위해 컴퓨터에 대한 언급은 배제하였다.</figcaption>
</figure>

<br/>
<br/>

당신은 조에게 전화를 걸어, “돈을 송금했어. 다음번에 네가 은행에 가면 내가 방금 송금한 1000불을 뽑을 수 있을 거야”라고 말한다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./joe3.png" alt="joe3">
</figure>

방금 무슨 일이 일어났는가? 당신과 조 둘 다 은행이 당신 돈을 관리하는 것을 신뢰하였다.  돈을 송금하기 위한 물리적인 화폐의 이동은 전혀 없었다. 오직 필요한 것은 통장에 남는 거래 기록이다. 좀 더 정확히 말하자면, 당신과 조가 컨트롤하거나 소유하지 않은 그 거래 기록 말이다.
<br/>
<br/>
바로 이것이 현 시스템의 문제이다.


<h4>상호 간의 신뢰를 확립하기 위하여, 우리는 제삼자에 의존한다.</h4>

수 년동안 우리는 서로를 신뢰하기 위해 이러한 중간자들에게 의존해 왔다. 당신은 그들에게 의존하는 것이 무슨 문제냐고 반론할 수도 있다.

이것의 문제는 단일한 개수에 있다. 만약 사회가 혼돈에 휩쓸리게 되면, 단 하나의 사람/단체만으로, 의도했던 의도치 않았든 간에, 모든 시스템이 무너질 수 있다.
<ul>
	<li>만약 거래 내역을 기록한 통장이 불에 타버린다면? </li>
	<li>만약 은행원이 실수로 1000 달러가 아닌 1500 달러를 기입한다면?</li>
	<li>만약 그가 의도적으로 그랬다면?</li>
</ul>

<h4>오랫동안 우리는 우리의 모든 달걀을 한 바구니 안에 담아 왔고 심지어 그 바구니 조차 다른 사람이 관리해왔다.</h4>

은행 없이 돈을 송금할 수 있는 시스템이 존재할 수 있을까?

이러한 질문에 답하기 위해서, 우리는 좀 더 깊게 파고들어 우리 자신에게 더 나은 질문을 해야 한다. (더 나은 질문만이 더 좋은 답을 도출할 수 있다)

잠시 동안 생각해 보자, 돈을 송금한다는 것은 어떤 의미인가? 통장에 기록되는 것이 전부이다. 더 좋은 질문은 아마 아래와 같을 것이다.

<br/>

*다른 사람이 우리 통장 기록을 대신 관리해 주는 대신, 우리끼리 이런 기록을 남길 방법이 없을까?*

<br/>

이 질문은 좀 더 고민해볼 가치가 있다. 그리고 아마 이 질문에 대한 해답을 당신은 이미 예상했을 것이다. 블록체인이 이러한 심도 깊은 질문의 답이다.

블록체인은 타인에게 의존하는 대신 우리끼리 거래 기록을 보관하는 방법이다. 잘 따라오고 있는가? 그럼 다행이다 왜냐면 당신 머릿속에 몇 가지 질문이 떠오르기 시작한 지금,  분산 기록이 어떻게 작동하는지에 대해 알아보자.

## 알겠어요, 근데 원리가 대체 뭔데요?
이 방법의 <strong>필수 조건은 </strong>제삼자에게 의존하고 싶지 않은 사람이 충분히 있어야 한다. 그래야만 이 그룹이 자신들끼리 기록을 남길 수 있다.

<figure>
	<blockquote>
		<p>비트 코인이 인기를 얻기 시작한다면 비트 코인을 사는 것은 타당한 일일 것이다. 만약 충분히 많은 사람이 이처럼 생각한다면 이게 바로 자기 충족적 예언이 되는 것이다. </p>
		<footer>
			<cite>- 사토시 나카모토, 2009</cite>
		</footer>
	</blockquote>
</figure>

그럼 얼마나 많이 필요한가? 최소한 세 명은 필요한다. 우리 예제에서는 열 명의 개인이 은행 또는 제삼자의 개입을 원치 않는다고 가정하겠다. 상호 동의를 통해, 이 그룹 안에 모두는 서로의 신원을 모른 채 각자의 계좌에 대한 세부 정보를 항시 가지고 있는다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./group1.png" alt="group1">
</figure>

<strong>1. 빈 폴더</strong><br/>
열 명 모두 각자 빈 폴더를 가지고 시작한다. 시간이 지남에 따라, 이 안에 열 명 모두는 현재 빈 폴더에 새로운 페이지들을 추가할 것이다. 이런 페이지들의 모임이 모두의 거래 내역을 추적하는 기록이 될 것이다.

<br/>

<strong>2. 거래가 일어날 때</strong><br/>
이 그룹에 모두는 해당 시스템 안에서 일어나는 모든 거래를 받아 적을 준비가 되어 있는 채 빈 종이와 펜을 손에 들고 둘러앉는다.

이제, 2번이 9번에게 10 달러를 보내고 싶어 한다.

이체를 하기 위해선, 2번은 모두에게 “나 9번한테 10 달러 보내고 싶으니깐, 모두들 각자 종이에 잘 적어놔 둬.”라고 외친다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./group2.png" alt="group2">
</figure>

2번이 9번에게 10불을 보낼 충분한 돈이 있는지 모두 확인한다. 만약 그녀가 잔액이 충분하다면 각자의 빈 종이에 해당 거래 내역을 기록한다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./group3.png" alt="group3">
	<figcaption>첫 번째 거래</figcaption>
</figure>

<br/>

<strong>3. 거래가 계속해서 일어난다</strong><br/>
시간이 지남에 따라 그룹 안에 더 많은 사람들이 서로에게 돈을 보낼 필요를 느낀다. 거래를 하고 싶을 때마다 그들은 해당 사실을 모두에게 알린다. 거래 공지를 들은 후 각 개개인은 자신의 종이에 이를 기입한다.

이러한 행위는 현재 페이지의 공간이 다 찰 때까지 계속된다. 종이 당 열 번의 거래를 기입할 수 있는 공간이 있다고 가정하면, 열 번째 거래가 종료되는 순간, 각자의 종이에 공간이 부족하게 된다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./group4.png" alt="group4">
	<figcaption>종이가 다 차게 됐을 때</figcaption>
</figure>

그럼 폴더 내에 현재 페이지를 보관하고 새로운 페이지를 꺼내 2번째 단계부터 반복하면 된다.

<br/>

<strong>4. 페이지를 보관하는 법</strong><br/>
우리 폴더에 있는 종이를 치우기 전, 그룹 내에 모두가 동의하는 특별한 키 (unique key)로 해당 페이지를 봉해야 한다. 이걸 봉인 함에 따라 폴더로 이전된 페이지가 절대 변경될 수 없게 된다. 폴더 내에 보관되는 순간, 폴더 내에 봉해진 채로 영원히 있게 된다. 또한 만약 모두가 해당 봉인을 신뢰한다면, 모두가 페이지 내에 정보를 신뢰하는 샘이 된다. 이러한 페이지의 봉인이 이 방법의 핵심이다.

<br/>

><strong>[용어 사전] </strong>
 페이지를 봉하는 법을 보통 ‘채굴한다(mining)’라고 표현하지만, 편의성을 위해 우리는 계속해서 ‘봉(인) 한다(sealing)’라고 부르겠다.

 <br/>

예전엔 제삼자 또는 중간자들이 작성된 거래 내역이 절대 변경되지 않을 것이라는 신뢰를 주었다면, 방금 설명한 분산되고 분권화된 시스템에서는 이 봉인이 이러한 신뢰를 대체한다.

## 흥미롭네요! 그러면 페이지를 어떻게 봉하나요?
어떻게 페이지를 봉할 수 있는지에 대해 알아보기 전 이 봉인이 어떻게 작동하는지에 대해 알아보자. 이것에 대한 선행 학습으로 아래의 개념을 먼저 이해해야 한다.

<strong>마법 기계</strong><br/>
두꺼운 벽에 둘러 쌓인 기계를 하나 상상해 보자. 만약 당신이 이 기계에 왼쪽으로 내용물이 담긴 상자를 보내면, 이 기계는 다른 내용물이 담긴 상자를 뱉어 낸다.

><strong>[용어 사전] </strong>
이 기계는 ‘해시 함수(Hash Function)’이라고 불리지만 우리는 여기서 너무 디테일하게 들어가지 않기로 하자. 따라서 이것들은 그냥 ‘마법 기계(magic machine)’이다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash1.png" alt="hash1">
	<figcaption>마법 기계 (또는 해시 함수)</figcaption>
</figure>

당신이 왼쪽으로 숫자 4를 보냈을 때 기계가 오른쪽으로 ‘dcbea’를 출력한다고 가정해 보자. 어떻게 숫자 4를 이처럼 변환했는지는 아무도 모른다. 이는 비가역적인 프로세스이다. 즉, ‘dcbea’가 주어졌을 때 왼쪽에서 입력 값으로 무엇을 들어왔는지 절대 알 수 없다. 대신 이 기계에 숫자 4를 입력할 때마다 ‘dcbea’를 동일하게 출력한다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash2.png" alt="hash2">
	<figcaption>hash(4) == dcbea</figcaption>
</figure>

‘dcbea’만 가지고는 왼쪽에서 들어온 입력 값을 알기란 불가능하지만 해당 기계에 숫자 4를 입력할 때마다 ‘dcbea’가 동일하게 출력된다.

다른 숫자로 실험해 보자. 26이 좋을 것 같다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash3.png" alt="hash3">
	<figcaption>hash(26) == 94c8e</figcaption>
</figure>

이번엔 ‘94c8e’를 얻었다. 흥미롭지 않은가! 결과 값에 숫자가 포함될 수 있다는 것을 알았다.

만약 다음과 같은 질문을 지금 한다면 어떠한가:

<br/>

*“000ab나 00098과 같이 앞 세 자리가 0으로 시작하는 단어를 결과 값으로 받으려면 기계에 입력 값으로 무엇을 주어야 하는가?”*

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash4.png" alt="hash4">
	<figcaption>입력값 예측하기</figcaption>
</figure>

이 질문에 대해 한 번 생각해 보자.

필자는 여러분에게 예상 결과 값만으로는 이에 상응하는 입력값을 계산할 수 없는 기계의 특징을 말해 주었는데, 위 질문을 어떻게 해결할 수 있을까?

한 가지 방법으로는 우주에 있는 모든 숫자를 하나씩 입력해 우리가 원하는 단어를 도출할 때까지 계속하는 것이다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash5.png" alt="hash5">
	<figcaption>입력 값을 계산하기 위해 모든 경우의 수를 대입한다</figcaption>
</figure>

<br/>

운이 좋으면 수천 번의 시도 후 우리가 원하는 결과 값을 얻을지도 모른다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash6.png" alt="hash6">
</figure>

결과값이 주어졌을 때 입력값을 계산하기란 무척 어려운 일이었지만 예측한 입력값이 필요한 결과값을 도출하는지 확인하는 것은 매우 쉽다. 이 기계가 동일한 입력값에 대해서는 항상 같은 결과값을 내놓는다는 것을 명심하자.

만약 필자가 여러분에게 예를 들어 72533이라는 숫자를 주고 해당 숫자가 기계에 입력되었을 때 앞자리가 0인 단어를 도출하는지에 대해 물어보면 대답하기 어렵겠는가?

해당 값을 기계에 입력 후 결과값만 확인하면 된다. 매우 간단하다.

이 기계의 가장 주요한 특징은 다음과 같다. “결과값만으로 입력값을 계산하기란 무척 어렵지만, 결과값과 입력값이 주어졌을 때 해당 입력값이 결과값을 도출하는지 확인하기란 꽤나 쉽다."

이 글을 읽는 내내 이 마술 기계 (또는 해시 함수)에 대해서 명심하도록 하자.

## 어떻게 이러한 기계를 이용해 페이지를 봉하는가?
이 마법 기계를 이용해 우리 페이지를 봉할 인장을 만들어 보자. 가상의 상황을 상정해보도록 하자.

만약 필자가 당신에게 두 개의 상자를 주었다고 가정해 보자. 첫 번째 상자는 숫자 20893을 가지고 있다. 필자는 당신에게 첫 번째 상자 안에 있는 숫자와 더해졌을 때 앞 세 자리가 0인 결과값을 도출하는 숫자를 찾아라고 묻는다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash7.png" alt="hash7">
</figure>

이 전에 봤던 상황과 비슷하다. 우리는 그런 숫자를 계산할 수 있는 방법은 지구 상에 존재하는 모든 숫자를 대입해 보는 수밖에 없다는 것도 잘 알고 있다.

수천 번의 시도 후, 21191이 20893과 더해진 후 (21191 + 20893 = 42084) 기계에 입력될 때 우리의 조건에 맞는 단어를 도출한다고 가정해 보자.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash8.png" alt="hash8">
</figure>

이런 경우, 숫자 21191이 숫자 20893의 인장이 된다. 숫자 20893이 적힌 종이가 있다고 가정해 보자. 이 페이지를 봉하기 위해서 (또는 해당 페이지의 내용을 그 누구도 변경할 수 없게 하기 위해서) 그 위에 ‘21191’이라고 적힌 배지를 부친다. 봉인 번호가 페이지에 부착되면 페이지는 봉인된다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./seal.png" alt="seal">
	<figcaption>봉인 번호</figcaption>
</figure>

<br/>

*<strong>[용어 사전] </strong>
이 봉인 번호는‘작업 증명 (Proof Of Work)’라고 불리는데 이는 해당 값의 계산을 위한 작업을 증명한다는 의미이다. 우리는 계속해서 ‘봉인 번호’라고 부르겠다.*

<br/>

만약 누군가 페이지가 변경됐는지 확인하고 싶다면, 페이지의 내용과 봉인 번호를 더해 마법 기계에 입력값으로 주면 된다. 만약 기계가 앞 세 자리가 0인 값을 준다면 내용이 변경되지 않은 것이고 조건과 다른 값이 도출된다면 내용이 오염되어 쓸모없어졌기에 해당 페이지를 버리면 된다.

우리는 동일한 봉인 원리를 이용하여 모든 페이지를 봉하고 각자의 폴더에 정렬하겠다.

## 마지막으로, 페이지를 봉인하기 위해…
그룹 내의 거래 내역이 들어간 페이지를 봉하기 위해서는 거래 목록과 더해져 기계로 입력되었을 때 앞 세 자리가 0인 값을 도출할 수 있는 숫자를 찾아야 한다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash9.png" alt="hash9">
</figure>

*필자는 계속해서 ‘앞 세 자리가 0인’이라는 표현을 예시로 써왔다. 이는 해시 함수가 어떻게 작동하는지 나타낸다. 실제로는 이것보다 훨씬 복잡한 원리를 사용한다.*

시간과 전력을 소비해 값이 계산되면 페이지가 해당 값으로 봉해진다. 만약 누군가 페이지의 내용을 변경하려 할 시 봉인 번호가 해당 페이지의 완전성 (integrity)를 확인해 줄 수 있다.

이제 페이지의 봉인 방법에 대해 알아봤으니, 열 번째 거래를 마치고 더 이상 쓸 공간이 없어졌을 때로 돌아가 보자.

더 이상 거래를 적을 수 있는 공간이 없을 때 페이지를 봉인 후 폴더에 보관하기 위해 각자 봉인 번호를 계산하기 시작한다. 그룹 내에 모두가 계산에 참여한다. 첫 번째로 계산을 마친 사람이 모두에게 이를 알린다.

<figure class="floatCenter">
	<img style="height: 600px; " src="./group5.png" alt="group5">
</figure>

봉인 번호를 들은 즉시, 각자 필요한 결과값을 도출하는지 확인 작업에 들어간다. 만약 조건을 충족한다면 그룹 내 전부는 해당 번호를 자신의 페이지에 표시하고 폴더에 보관하다.

그런데 만약 누군가에게는, 예를 들어 7번이, 공표된 봉인 번호가 필요한 결과값을 도출하지 못하면 어떻게 하는가? 이러한 경우는 꽤나 흔하다. 타당한 이유는 아마도:

<ul>
	<li>그룹 내에서 공지된 거래를 잘못 들었거나,  </li>
	<li>그룹 내에서 공지된 거래를 잘못 받아 적었거나, </li>
	<li>거래를 받아 적는 도중 자신이나 그룹 내 다른 이의 이익을 위해 거래를 조작했을 수도 있다.</li>
</ul>

이유가 무엇이든 간에, 7번에게는 한 가지 옵션밖에는 없다. 자신의 종이를 버리고 자신도 폴더에 보관하기 위하여 다른 사람 것을 베끼는 것이다. 그가 자신의 종이를 폴더에 넣기 전까지는 그는 더 이상의 거래를 받아 적을 수 없고 그룹 내에 일원이 될 수 없다.

<h4>다수가 동의한 봉인 번호가 정직한 봉인 번호가 된다. </h4>

*그렇다면 어째서 모두들 자신들의 자원을 써가면서 계산을 해야 하는 가? 어차피 그룹 내 누군가 계산 후 자신들 위해 발표해 준다면 그냥 가만히 앉아서 결과 발표를 기다리는 게 낫지 않은가?*

좋은 질문이다. 블록체인에 일부인 모두는 보상을 받을 수 있다. 봉인 번호를 계산한 첫 번째 사람의 노력을 치하하고자 그는 공짜 돈을 얻는다. (예를 들면 확장된  CPU 파워나 전력 등등)

만약 5번이 페이지의 봉인 번호를 계산해 낸다면, 그는 약간의 공짜 돈, 1달러라 가정해보자, 을 보상받게 된다. 다시 말하면, 5번의 잔액이 다른 누구의 잔액을 줄이지 않고도 1불 증가한다는 것이다.

이게 바로 비트코인이 존재하게 된 이유다. 비트 코인은 블록체인 또는 분산 기록에서 거래된 첫 번째 통화이다. 그룹 내에 계산을 하려는 노력을 유지시키기 위해 사람들은 비트 코인으로 보상을 받았다.

충분한 수의 사람들이 비트코인을 가지게 되었을 때, 비트코인의 가치는 올라가 더 많은 사람들이 이를 원하게 되어 비트코인의 가치는 더욱더 상승하게 되는 방식이다.

<h4>보상은 그룹 내 모두가 작업을 계속하게 한다. </h4>

각자의 폴더에 페이지를 다 보관 후, 모두 새 빈 종이를 꺼내 이러한 프로세스를 계속 반복한다.

<br/>

><strong>[용어 사전] </strong>
 하나의 페이지를 거래의 블록이라 가정하고 폴더를 페이지 또는 블록의 체인이라 생각해보자. 즉, 블록체인이 되는 것이다.

<br/>

이게 바로 블록체인의 원리이다.

***

그런데 아직 필자가 여러분에게 말하지 않은 것이 하나 있다.

예를 들어 폴더 내에 이미 봉인 번호로 봉해진 다섯 장의 페이지가 있다고 상상해 보자. 만약 필자가 두 번째 페이지를 열어 필자가 이득을 보도록 거래 내역을 변경하면 어떻게 되겠는가? 봉인 번호를 통해 모두가 거래가 불일치한다는 걸 알 수 있지 않겠는가? 만약 필자가 변경된 거래를 위해 새로운 봉인 번호를 계산 후 해당 페이지를 그 번호로 봉하면 어떻게 되겠는가?

누군가 이미 끝낸 페이지로 돌아가 페이지(블록)를 변경하고 봉인 번호마저 바꾸는 이러한 문제점을 방지하기 위해 봉인 번호가 계산되는 과정에 약간의 트릭이 있다.

## 봉인 번호의 변경 방지하기
필자가 하나는 20893이 담겨 있고 하나는 여러분이 계산하도록 놔둔 빈 상자 두 개를 여러분에게 주었던 것 기억하는가? 실제로는 블록체인은 봉인 번호를 계산하기 위해서는 상자 두 개가 아니라 세 개가 필요하다 - 미리 채워진 두 개와 계산할 하나이다.

세 상자의 내용물이 전부 더해져 기계로 입력되었을 때 결과 값은 항상 필요한 조건을 충족해야 한다.

우리는 이미 상자 하나는 거래 목록을 보관하고 나머지 하나는 봉인 번호를 보관하고 있다는 걸 알고 있다. 마지막 세 번째 상자는 마법 기계가 내놓은 지난 페이지의 결과값을 가지고 있다.  

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash10.png" alt="hash10">
</figure>

이러한 방법을 통해 우리는 모든 페이지가 그 전 페이지의 의존하도록 하였다. 결론적으로, 만약 누군가 옛 페이지를 변경하려 한다면 체인을 일치시키기 위해 해당 페이지 다음에 존재하는 모든 페이지들의 내용과 봉인 번호를 변경해야만 한다.

만약 앞서 언급한 열 명 중 한 명이 블록체인(거래 목록을 간직한 폴더)의 내용을 변경하려 한다면 여러 장의 페이지를 변경해야 하고 각 페이지마다 새로운 봉인 번호를 계산해야 한다. 우리는 봉인 번호를 계산하는 것이 얼마나 어려운지 알고 있다. 따라서 그룹 내 한 명의 부정직한 사람은 나머지 정직한 아홉 명을 이기지 못한다.  
부정직한 사람이 조작하려는 페이지부터 그는 그룹 내에 새로운 체인을 만들게 되는 데 이 체인은 절대 원 체인을 따라잡지 못한다. 왜냐면 한 사람의 작업 속도는 아홉 명의 누적된 작업 속도를 이길 수 없기 때문이다. 즉, 가장 긴 체인이 그룹 내에 가장 정확한 체인이 되는 것이다.

<h4>가장 긴 체인이 가장 정확한 체인이다. </h4>

<figure class="floatCenter">
	<img style="height: 600px; " src="./hash10.png" alt="hash10">
	<figcaption>가장 긴 체인이 가장 정확한 체인이다. </figcaption>
</figure>

필자가 부정직한 한 명이 나머지 정직한 아홉 명을 이길 수 없다고 했을 때 여러분 머리 속에서 무언가 떠오르지 않았는가?

<br/>

## 만약 한 명이 아니라 여섯 명이 조작을 하려 한다면?
이 경우 미리 정한 규약이 깨지게 되고 이는 “51%의 공격”이라고 불린다. 만약 그룹 내에 대다수가 부정직하게 돌변하여 조작을 하려 한다면, 상호 간의 약속은 원래의 목적을 상실하게 된다.

이것이 만약 블록체인이 무너질 수 있는 유일한 약점이다. 비록 이런 일이 생길 가능성은 낮지만 시스템의 약점을 아는 것은 매우 중요하다. 블록체인은 다수가 항상 정직할 것이라는 가정 하에 존재한다.

이것이 바로 블록체인에 관한 모든 것이다. 이 글을 즐겨찾기 해놓고 누군가 당신에게 “도대체 블록체인이 뭐야”라고 묻는다면 이 글을 보여줘라.  

<br/>
